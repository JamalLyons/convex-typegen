use std::{fs::File, io::{Write, Seek, SeekFrom}};

use crate::ast::ConvexSchema;

#[derive(Debug)]
pub(crate) struct Builder {
    pub(crate) schema: ConvexSchema,
}

impl Builder {
    pub(crate) fn new(schema: ConvexSchema) -> Self {
        Self { schema }
    }

    pub(crate) fn generate(&self, file_path: &str) -> std::io::Result<()> {
        // Write the generated code to a file
        let mut file = File::create(file_path)?;

        // Clear the content of the file before writing
        file.set_len(0)?;
        file.seek(SeekFrom::Start(0))?;

        // Comments at the top of the generated file
        let comments = "\
// This schema.rs was auto generated by the convex-typegen crate. Modify at your own risk.\n\
// For more information, visit https://github.com/ThatGuyJamal/convex-typegen\n\n";

 // Write comments to the file
    file.write_all(comments.as_bytes())?;

        let mut code = String::new();

        for table in self.schema.tables.iter() {
            if let Some(funcs) = self.schema.functions.get(&table.name) {
                let enum_name = self.capitalize_first_char(&table.name);
                code.push_str(&format!("pub enum {} {{\n", enum_name));
                for func in funcs {
                    code.push_str(&format!("    {},\n", self.capitalize_first_char(&func)));
                }
                code.push_str("}\n\n");

                // Generating impl block for enum to string conversion
                code.push_str(&format!("impl {} {{\n", enum_name));
                code.push_str(&format!("    pub fn to_string(&self) -> &'static str {{\n"));
                code.push_str("        match self {\n");
                for func in funcs {
                    code.push_str(&format!(
                        "            {}::{} => \"{}:{}\",\n",
                        enum_name,
                        self.capitalize_first_char(&func),
                        &table.name,
                        &func
                    ));
                }
                code.push_str("        }\n");
                code.push_str("    }\n");

                // Generating string to enum conversion
                code.push_str(&format!(
                    "    pub fn from_string(s: &str) -> Option<Self> {{\n"
                ));
                code.push_str("        match s {\n");
                for func in funcs {
                    code.push_str(&format!(
                        "            \"{}:{}\" => Some({}::{}),\n",
                        &table.name,
                        &func,
                        enum_name,
                        self.capitalize_first_char(&func)
                    ));
                }
                code.push_str("            _ => None,\n");
                code.push_str("        }\n");
                code.push_str("    }\n");
                code.push_str("}\n");
            }
        }

        // Write the generated string to the file
        file.write_all(code.as_bytes())?;

        Ok(())
    }

    fn capitalize_first_char(&self, s: &str) -> String {
        let mut chars = s.chars();
        match chars.next() {
            None => String::new(),
            Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
        }
    }
}
