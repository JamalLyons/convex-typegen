// This file is generated by convex-typegen. Do not modify directly.
// You can find more information about convex-typegen at https://github.com/JamalLyons/convex-typegen

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use serde::{Serialize, Deserialize};

#[derive(Debug, Clone)]
pub enum Test_simple_union {
    String(String),
    Number(f64),
}

#[derive(Debug, Clone)]
pub enum Test_complex_union {
    String(String),
    Number(f64),
    Boolean(bool),
    Null(()),
    Array(Vec<String>),
}

#[derive(Debug, Clone)]
pub enum Test_literal_union {
    Draft,
    Published,
    Archived,
}

#[derive(Debug, Clone)]
pub enum TestOptional_optional_union {
    String(String),
    Number(f64),
}

#[derive(Debug, Clone)]
pub struct TestTable {
    pub _id: String,
    pub _null: (),
    pub _int64: i64,
    pub _float64: f64,
    pub _boolean: bool,
    pub _string: String,
    pub _bytes: Vec<u8>,
    pub _simple_array: Vec<String>,
    pub _number_array: Vec<f64>,
    pub _mixed_array: Vec<serde_json::Value>,
    pub _nested_array: Vec<Vec<String>>,
    pub _deep_nested_array: Vec<Vec<Vec<f64>>>,
    pub _simple_object: std::collections::BTreeMap<String, String>,
    pub _complex_object: std::collections::BTreeMap<String, bool>,
    pub _nested_object: std::collections::BTreeMap<String, std::collections::BTreeMap<String, std::collections::BTreeMap<String, String>>>,
    pub _string_record: std::collections::HashMap<String, String>,
    pub _number_record: std::collections::HashMap<String, f64>,
    pub _complex_record: std::collections::HashMap<String, serde_json::Value>,
    pub _simple_union: Test_simple_union,
    pub _complex_union: Test_complex_union,
    pub _literal_union: Test_literal_union,
    pub _optional_string: Option<String>,
    pub _optional_object: Option<std::collections::BTreeMap<String, String>>,
    pub _optional_union: Option<TestOptional_optional_union>,
    pub _optional_array: Option<Vec<String>>,
    pub _complex_nested: std::collections::BTreeMap<String, std::collections::BTreeMap<String, std::collections::HashMap<String, f64>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestMutationArgs {
    pub saveTest: String,
}

impl From<TestMutationArgs> for std::collections::BTreeMap<String, serde_json::Value> {
    fn from(args: TestMutationArgs) -> Self {
        let mut map = std::collections::BTreeMap::new();
        map.insert("saveTest".to_string(), serde_json::to_value(args.saveTest).unwrap());
        map
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestQueryArgs {
    pub test: String,
}

impl From<TestQueryArgs> for std::collections::BTreeMap<String, serde_json::Value> {
    fn from(args: TestQueryArgs) -> Self {
        let mut map = std::collections::BTreeMap::new();
        map.insert("test".to_string(), serde_json::to_value(args.test).unwrap());
        map
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestQuery22Args {
    pub test: String,
}

impl From<TestQuery22Args> for std::collections::BTreeMap<String, serde_json::Value> {
    fn from(args: TestQuery22Args) -> Self {
        let mut map = std::collections::BTreeMap::new();
        map.insert("test".to_string(), serde_json::to_value(args.test).unwrap());
        map
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplexQueryArgs {
    pub id: String,
    pub filters: Vec<std::collections::BTreeMap<String, String>>,
    pub pagination: Option<std::collections::BTreeMap<String, f64>>,
    pub sort: serde_json::Value,
    pub nested: std::collections::BTreeMap<String, std::collections::BTreeMap<String, Vec<String>>>,
}

impl From<ComplexQueryArgs> for std::collections::BTreeMap<String, serde_json::Value> {
    fn from(args: ComplexQueryArgs) -> Self {
        let mut map = std::collections::BTreeMap::new();
        map.insert("id".to_string(), serde_json::to_value(args.id).unwrap());
        map.insert("filters".to_string(), serde_json::to_value(args.filters).unwrap());
        map.insert("pagination".to_string(), serde_json::to_value(args.pagination).unwrap());
        map.insert("sort".to_string(), serde_json::to_value(args.sort).unwrap());
        map.insert("nested".to_string(), serde_json::to_value(args.nested).unwrap());
        map
    }
}

