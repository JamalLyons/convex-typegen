use std::fs::File;
use std::io::Write;
use std::path::Path;

use serde_json::Value as JsonValue;

use crate::convex::{ConvexFunction, ConvexFunctionParam, ConvexSchema, ConvexTable};
use crate::errors::ConvexTypeGeneratorError;

pub(crate) struct CodeGenerator {
    schema: ConvexSchema,
    functions: Vec<ConvexFunction>,
}

impl CodeGenerator {
    pub fn new(schema: ConvexSchema, functions: Vec<ConvexFunction>) -> Self {
        Self { schema, functions }
    }

    pub fn generate(&self, out_file: &str) -> Result<(), ConvexTypeGeneratorError> {
        let mut file = File::create(Path::new(out_file))?;

        // Write the header with necessary imports
        self.write_header(&mut file)?;
        
        // Generate database types
        self.generate_database_types(&mut file)?;
        
        // Generate function types
        self.generate_function_types(&mut file)?;

        Ok(())
    }

    fn write_header(&self, file: &mut File) -> Result<(), ConvexTypeGeneratorError> {
        let header = r#"#![allow(non_snake_case)]

// This file was generated by convex-type-generator. Do not edit.
use std::collections::BTreeMap;
use serde_json::Value as JsonValue;

// Type alias for Convex's `any` type - implement as needed
pub type ConvexAny = JsonValue;

"#;
        file.write_all(header.as_bytes())?;
        Ok(())
    }

    fn generate_database_types(&self, file: &mut File) -> Result<(), ConvexTypeGeneratorError> {
        for table in &self.schema.tables {
            self.generate_table_type(file, table)?;
        }
        Ok(())
    }

    fn generate_table_type(&self, file: &mut File, table: &ConvexTable) -> Result<(), ConvexTypeGeneratorError> {
        writeln!(file, "#[derive(Debug, Clone)]")?;
        let table_name = format!("{}Table", capitalize_first(&table.name));
        writeln!(file, "pub struct {} {{", table_name)?;
        
        for column in &table.columns {
            let rust_type = self.convert_type_to_rust(&column.data_type)?;
            writeln!(file, "    pub {}: {},", column.name, rust_type)?;
        }
        
        writeln!(file, "}}\n")?;
        Ok(())
    }

    fn generate_function_types(&self, file: &mut File) -> Result<(), ConvexTypeGeneratorError> {
        for function in &self.functions {
            if !function.params.is_empty() {
                self.generate_function_args_type(file, function)?;
            }
        }
        Ok(())
    }

    fn generate_function_args_type(&self, file: &mut File, function: &ConvexFunction) -> Result<(), ConvexTypeGeneratorError> {
        writeln!(file, "#[derive(Debug, Clone)]")?;
        writeln!(file, "pub struct {}Args {{", capitalize_first(&function.name))?;
        
        for param in &function.params {
            let rust_type = self.convert_type_to_rust(&param.data_type)?;
            writeln!(file, "    pub {}: {},", param.name, rust_type)?;
        }
        
        writeln!(file, "}}")?;
        writeln!(file)?;
        Ok(())
    }

    fn convert_type_to_rust(&self, convex_type: &JsonValue) -> Result<String, ConvexTypeGeneratorError> {
        let type_name = convex_type["type"].as_str()
            .ok_or_else(|| ConvexTypeGeneratorError::InvalidSchema("Invalid type".into()))?;

        Ok(match type_name {
            "string" => "String".into(),
            "number" | "float64" => "f64".into(),
            "int64" => "i64".into(),
            "boolean" => "bool".into(),
            "null" => "Option<()>".into(),
            "array" => {
                let element_type = self.convert_type_to_rust(&convex_type["elements"])?;
                format!("Vec<{}>", element_type)
            },
            "object" => {
                if let Some(properties) = convex_type["properties"].as_object() {
                    format!("BTreeMap<String, {}>", "ConvexAny")
                } else {
                    "BTreeMap<String, ConvexAny>".into()
                }
            },
            "optional" => {
                let value_type = self.convert_type_to_rust(&convex_type["value"])?;
                format!("Option<{}>", value_type)
            },
            "any" => "ConvexAny".into(),
            "union" => "ConvexAny".into(),
            "id" => "ConvexAny".into(),
            "bytes" => "ConvexAny".into(),
            _ => "ConvexAny".into(),
        })
    }
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}
